import requests
import time
from Crypto.Cipher import AES
import base64
import threading
import http.server
import socketserver
import random
import os
import json
from queue import Queue

LOCAL_EXFIL_SERVER_PORT = 8080
EXFIL_DOMAINS = [f"http://localhost:{LOCAL_EXFIL_SERVER_PORT}/exfil"]
ENCRYPTION_KEY = "thisisasecretkey" 
LOG_FILE = "scan_results.log"

exfil_server_ready = Queue()

def hacker_interface():
    print("\033[1;32m" + "=" * 50)
    print("       WELCOME TO THE W00DEATH by ro7t3r")
    print("=" * 50 + "\033[0m")
    print("""
1. Scan and detect vulnerabilities
2. Exploit vulnerabilities with exfiltration
3. Batch process targets from file
4. Exit
    """)
    print("=" * 50)

def start_exfil_server(port=8080):
    class ExfilHandler(http.server.SimpleHTTPRequestHandler):
        def do_POST(self):
            try:
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                print(f"\033[1;36m[+] Exfiltrated Data Received: {post_data.decode()}\033[0m")
                with open("exfil_data.log", "a") as f:
                    f.write(post_data.decode() + "\n")
                self.send_response(200)
                self.end_headers()
            except Exception as e:
                print(f"[!] Error in exfiltration server: {e}")

    try:
        with socketserver.TCPServer(("", port), ExfilHandler) as server:
            print(f"\033[1;32m[*] Exfiltration server running on port {port}\033[0m")
            exfil_server_ready.put(True)  # Notify main thread that the server is ready
            server.serve_forever()
    except OSError as e:
        print(f"[!] Port {port} is already in use. Exfiltration server failed to start.")
        exfil_server_ready.put(False)

def encrypt_data(data, key):
    try:
        cipher = AES.new(key.encode('utf-8'), AES.MODE_GCM)
        nonce = cipher.nonce
        ciphertext, tag = cipher.encrypt_and_digest(data.encode('utf-8'))
        return {
            "nonce": base64.b64encode(nonce).decode(),
            "ciphertext": base64.b64encode(ciphertext).decode(),
            "tag": base64.b64encode(tag).decode()
        }
    except Exception as e:
        print(f"[!] Encryption error: {e}")
        return None

def detect_platform(target_url):
    try:
        print(f"[*] Scanning {target_url}...")
        headers = {"User-Agent": "Mozilla/5.0"}
        response = requests.get(target_url, headers=headers, timeout=10)
        if response.status_code == 200:
            if "wp-content" in response.text:
                print(f"[+] WordPress/WooCommerce detected at {target_url}")
                return "WordPress"
            elif "Magento" in response.text:
                print(f"[+] Magento detected at {target_url}")
                return "Magento"
            elif "PrestaShop" in response.text:
                print(f"[+] PrestaShop detected at {target_url}")
                return "PrestaShop"
            elif "Shopify" in response.text:
                print(f"[+] Shopify detected at {target_url}")
                return "Shopify"
            else:
                print(f"[-] Unknown platform at {target_url}")
        else:
            print(f"[!] Target {target_url} is not accessible.")
    except Exception as e:
        print(f"[!] Error detecting platform: {e}")
    return None

def test_vulnerabilities(platform, target_url):
    vulnerabilities = []
    print(f"[*] Testing vulnerabilities for {platform}...")
    try:
        if platform == "WordPress":
            vulnerabilities.append("Weak admin password")
            vulnerabilities.append("Unsecured wp-content directory")
        elif platform == "Magento":
            vulnerabilities.append("Admin panel exposed")
            vulnerabilities.append("Known RCE exploit")
        elif platform == "PrestaShop":
            vulnerabilities.append("SQL injection in search feature")
        elif platform == "Shopify":
            vulnerabilities.append("Insecure third-party apps")
    except Exception as e:
        print(f"[!] Error testing vulnerabilities: {e}")
    print(f"[+] Found vulnerabilities: {', '.join(vulnerabilities)}")
    return vulnerabilities

def exploit_and_exfiltrate(target_url, vulnerabilities):
    try:
        exfil_thread = threading.Thread(target=start_exfil_server, args=(LOCAL_EXFIL_SERVER_PORT,), daemon=True)
        exfil_thread.start()

        if exfil_server_ready.get(): 
            print("[*] Exfiltration server is ready. Starting exploitation...")
            for vuln in vulnerabilities:
                print(f"[*] Exploiting {vuln} on {target_url}...")
                time.sleep(2)
                print(f"[+] Successfully exploited {vuln}")
                exfiltrate_data(target_url)
        else:
            print("[!] Exfiltration server failed to start. Exploitation aborted.")
    except Exception as e:
        print(f"[!] Error during exploitation: {e}")

def exfiltrate_data(target_url):
    test_data = json.dumps({"cc": "4111111111111111", "exp": "12/25", "cvv": "123"})
    encrypted = encrypt_data(test_data, ENCRYPTION_KEY)
    if encrypted:
        try:
            exfil_url = random.choice(EXFIL_DOMAINS)
            response = requests.post(exfil_url, json=encrypted, timeout=10)
            print(f"[+] Exfiltration to {exfil_url} succeeded with status: {response.status_code}")
        except Exception as e:
            print(f"[!] Exfiltration error: {e}")

def log_results(target_url, platform, vulnerabilities):
    try:
        with open(LOG_FILE, "a") as log_file:
            log_file.write(f"Target: {target_url}\n")
            log_file.write(f"Platform: {platform}\n")
            log_file.write(f"Vulnerabilities: {', '.join(vulnerabilities)}\n")
            log_file.write("=" * 50 + "\n")
    except Exception as e:
        print(f"[!] Logging error: {e}")

if __name__ == "__main__":
    while True:
        hacker_interface()
        choice = input("\033[1;33mEnter your choice (1-4): \033[0m")

        if choice == "1":
            target_url = input("\033[1;33mEnter target URL: \033[0m")
            platform = detect_platform(target_url)
            if platform:
                vulnerabilities = test_vulnerabilities(platform, target_url)
                log_results(target_url, platform, vulnerabilities)
        elif choice == "2":
            target_url = input("\033[1;33mEnter target URL: \033[0m")
            platform = detect_platform(target_url)
            if platform:
                vulnerabilities = test_vulnerabilities(platform, target_url)
                exploit_and_exfiltrate(target_url, vulnerabilities)
                log_results(target_url, platform, vulnerabilities)
        elif choice == "3":
            file_path = input("\033[1;33mEnter path to target file: \033[0m")
            with open(file_path, "r") as f:
                targets = f.readlines()
            for target in targets:
                target = target.strip()
                if target:
                    platform = detect_platform(target)
                    if platform:
                        vulnerabilities = test_vulnerabilities(platform, target)
                        exploit_and_exfiltrate(target, vulnerabilities)
                        log_results(target, platform, vulnerabilities)
        elif choice == "4":
            print("\033[1;32mExiting... Goodbye!\033[0m")
            break
        else:
            print("\033[1;31mInvalid choice. Please try again.\033[0m")
